<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Tiny5&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<script src="https://download.playfab.com/PlayFabClientApi.js"></script>
	<script src="https://sdk.playfabapi.com/js/PlayFabClientApi.js"></script>

    
     <style>
     @font-face {
font-family: "Tiny5";
src: url("https://path-to-your-font-file.ttf") format("truetype"); /* Update this URL to your actual font file */
font-weight: 400;
font-style: normal;
}

 body {
        margin: 0;
        padding: 0;
        overflow: auto;
        text-align: center;
        font-family: "Tiny5", sans-serif;
    }

    .canvas-container {
        position: relative;
        display: inline-block;
        width: 100%;
        max-width: 100%;
    }

canvas {
    align-items: center;
    display: block;
    margin: 0 auto;
    border: 3px solid black;
    width: 98%;
    height: 90vh;
    background-image: url('moon surface 2.png'), url('Ponke Chart Background.png'); /* Reverse the order */
    background-size: contain, cover; /* Moon surface adjusts size, main background fills */
    background-position: bottom, center; /* Align moon surface to bottom, background centered */
    background-repeat: no-repeat, no-repeat; /* Prevent repetition for both images */
    border-radius: 50px;
}

	
    /* CSS for volume controls */

    #startButton, #shopButton, #selectCharacterButton, #clearCacheButton, #highscoreButton, #pauseButton, #muteButton, #tweetScoreButton {
        position: absolute;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 20px;
        padding: 6px 15px;
        cursor: pointer;
        z-index: 2;
        border: none;
        color: white;
        border-radius: 30px;
        font-family: "Tiny5", sans-serif;
    }
	
     #totalPlayers {
    font-size: 24px; /* Adjust the font size as needed */
    text-align: center; /* Center align the text */
	}
    #tweetScoreButton { top: 12.5%; background-color: #a7ccf4; color: #000; }
    #startButton { top: 25%; background-color: #a7ccf4; color: #000; }
    #muteButton { top: 87.5%; background-color: #ff0000; }
    #pauseButton { top: 90%; background-color: #a7ccf4; color: #000; }
    #shopButton { top: 37.5%; background-color: #a7ccf4; color: #000; }
    #selectCharacterButton { top: 50%; background-color: #a7ccf4; color: #000; }
    #clearCacheButton { top: 75%; background-color: #ffec00; color: black; }
    #highscoreButton { top: 62.5%; background-color: #a7ccf4; color: #000; }

    #scoreText, #coinText {
        position: absolute;
        top: 20px;
        left: 15%;
        transform: translateX(-50%);
        font-size: 24px;
        color: white;
        z-index: 1;
        font-family: "Tiny5", sans-serif;
    }

    #coinText { top: 50px; }

  @media (max-height: 600px) {
    canvas {
        height: 90vh;
        width: 100%;
        max-width: 100%;
        background-size: cover;
        background-position: center;
    }

    /* iPhone 6/7/8 in portrait */
    @media (max-device-width: 375px) and (max-height: 667px) and (-webkit-device-pixel-ratio: 2) {
        canvas {
            height: 60vh;  /* Adjusted height percentage */
            width: 100%;    /* Adjusted width percentage */
        }
    }

    /* iPhone 6/7/8 in landscape */
    @media (max-device-width: 667px) and (max-height: 375px) and (-webkit-device-pixel-ratio: 2) {
        canvas {
            height: 90vh;  /* Adjusted height percentage */
            width: 100%;
        }
    }
    /* Media query for smaller devices */
    @media (max-width: 768px) {
    canvas {
        width: 100%; /* 100% width for small devices */
        height: 60vh; /* Adjust height as needed */
    }
}
    /* iPhone 15 in landscape */
    @media (max-device-width: 926px) and (max-height: 428px) and (-webkit-device-pixel-ratio: 3) {
        canvas {
            height: 90vh;  /* Adjusted height percentage */
            width: 100%;    /* Adjusted width percentage */
        }
    }

    /* iPhone 11/12/13/14 in portrait */
    @media (max-device-width: 414px) and (max-height: 896px) and (-webkit-device-pixel-ratio: 2) {
        canvas {
            height: 70vh;  /* Adjusted height percentage */
            width: 90%;    /* Adjusted width percentage */
        }
    }

    /* iPhone 11/12/13/14 in landscape */
    @media (max-device-width: 896px) and (max-height: 414px) and (-webkit-device-pixel-ratio: 2) {
        canvas {
            height: 80vh;  /* Adjusted height percentage */
            width: 100%;    /* Adjusted width percentage */
        }
    }


        #startButton, #shopButton, #selectCharacterButton, #clearCacheButton, #highscoreButton {
            font-size: 16px;
            padding: 8px 16px;
        }

        #startButton { top: 25%; }
        #shopButton { top: 37.5%; }
        #selectCharacterButton { top: 50%; }
        #clearCacheButton { top: 75%; }
        #highscoreButton { top: 62.5%; }
    }

    .modal {
        display: none;
        position: fixed;
        z-index: 3;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        max-width: 400px;
        max-height: 80%;
        overflow-y: auto;
        color: #000;
        background-color: #fff;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        font-family: "Tiny5", sans-serif;
    }
    

    .modal img {
        width: 150px;
        height: 170px;
        margin: 10px;
        cursor: pointer;
    }

    .modal-close {
        position: absolute;
        top: 10px;
        right: 10px;
        cursor: pointer;
        font-size: 25px;
    }

    .character-container {
        max-height: 60vh;
        overflow-y: auto;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
    }

    .character-item {
        text-align: center;
    }

    .character-item img {
        cursor: pointer;
        width: 85px;
        height: 100px;
    }

    #highscoreModal {
        display: none;
        position: fixed;
        z-index: 3;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        max-width: 400px;
        max-height: 80%;
        overflow-y: auto;
		color: #000;
        background-color: #fff;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        font-family: "Tiny5", sans-serif;
    }

    #highscoreModal img {
        width: 150px;
        height: 170px;
        margin: 10px;
        cursor: pointer;
    }

    #highscoreModal-close {
        position: absolute;
        top: 10px;
        right: 10px;
        cursor: pointer;
        font-size: 25px;
    }

    #highscoreList {}

    #usernameModal {
        display: none;
        position: fixed;
        z-index: 3;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        max-width: 400px;
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        font-family: "Tiny5", sans-serif;
    }

    #usernameInput {
        width: 80%;
        padding: 10px;
        font-size: 16px;
        margin: 10px 0;
    }

    #saveUsernameButton {
        padding: 10px 20px;
        font-size: 16px;
        background-color: #000;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    
    





    </style>
</head>


<body>

    <div class="canvas-container">
        <canvas id="gameCanvas"></canvas>
        <button id="tweetScoreButton" style="display: none;">Tweet Score</button>
        <button id="startButton">Start Game</button>
        <button id="shopButton">Shop</button>
        <button id="selectCharacterButton">Select Character</button>
        <button id="highscoreButton">Leaderboard</button>
        <button id="pauseButton" style="display:none;">Pause</button>
        <button id="muteButton">Mute</button>
        <button id="clearCacheButton">Clear Cache</button>
        
    </div>
    <p id="scoreText" style="display: none;">Score: 0</p>
    <p id="coinText" style="display: none;">Coins: 0</p>
    <form id="highscoreForm" style="display:none;">
    <input type="hidden" id="username" name="username">
    <input type="hidden" id="score" name="score">
</form>

<div id="usernameModal" class="modal">
    <div class="modal-content">
        <p>Please enter your username (max 20 characters):</p>
        <input type="text" id="usernameInput" maxlength="20">
        <button id="saveUsernameButton">Save</button>
        <div id="usernameValidationMessage"></div>
    </div>
</div>

    
   <div class="modal" id="shopModal">
        <span class="modal-close" id="shopModalClose">&times;</span>
        <h2>Shop</h2>
        <div id="coinCountDisplay">Coins: 0</div> <!-- Add this line -->
<div class="character-container" id="characters">
    <div class="character-item" data-character="character2">
        <img src="pixel art bonkey 02.png" alt="Character 2">
        <p>25 Coins</p>
    </div>
    <div class="character-item" data-character="character3">
        <img src="pixel art bonkey 03.png" alt="Character 3">
        <p>50 Coins</p>
    </div>
    <div class="character-item" data-character="character4">
        <img src="pixel art bonkey 04.png" alt="Character 4">
        <p>75 Coins</p>
    </div>
    <div class="character-item" data-character="character5">
        <img src="pixel art bonkey 05.png" alt="Character 5">
        <p>100 Coins</p>
    </div>
    <div class="character-item" data-character="character6">
        <img src="pixel art bonkey 06.png" alt="Character 6">
        <p>150 Coins</p>
    </div>
	<div class="character-item" data-character="character7">
        <img src="pixel art bonkey 07.png" alt="Character 7">
        <p>200 Coins</p>
    </div>
</div>


    </div>

    <div class="modal" id="selectCharacterModal">
        <span class="modal-close" id="selectCharacterModalClose">&times;</span>
        <h2>Select Character</h2>
        <div class="character-container" id="purchasedCharacters"></div>
    </div>

<div class="modal" id="highscoreModal">
    <span class="modal-close" id="highscoreModalClose">&times;</span>
    <h2>Leaderboard</h2>
    <div id="highscoreList"></div>
</div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
		PlayFab.settings.titleId = "8115B"; // Replace with your PlayFab Title ID

        
        
        
        
        

        const turtleImage = new Image();
        turtleImage.src = 'pixel art bonkey 01.png';
        
        const backgroundImage = new Image();
        backgroundImage.src = 'Ponke Chart Background.png'; 
		
		const moonSurfaceImage = new Image();
		moonSurfaceImage.src = 'moon surface 2.png';


        const coinImage = new Image();
        coinImage.src = 'coin.png';

        const characters = {
            character1: 'pixel art bonkey 01.png',
			character2: 'pixel art bonkey 02.png',
			character3: 'pixel art bonkey 03.png',
			character4: 'pixel art bonkey 04.png',
			character5: 'pixel art bonkey 05.png',
			character6: 'pixel art bonkey 06.png',
			character7: 'pixel art bonkey 07.png',
            
        };

        let selectedCharacter = localStorage.getItem('selectedCharacter') || 'character1';
        // Game speed scaler
		const gamespeedmodifier = 1;
		// Define initial and maximum gravity
		const initialGravity = 0.23; // Starting gravity (low)
		const maxGravity = 0.43;     // Maximum gravity (normal gameplay value)
		const gravityIncreaseDuration = 1500; // Time (in ms) to reach max gravity

		// Define initial and adjusted lift
		const initialLift = -5; // Stronger jump at low gravity
		const maxLift = -7.75;     // Normal jump at max gravity

		let currentGravity = initialGravity;
		let currentLift = initialLift;
		let gravityIncreaseStartTime = null;

		// Update the turtle object to use dynamic values
		const turtle = {
			x: canvas.width / 10,
			y: canvas.height / 2 - 25,
			width: 64,
			height: 64,
			gravity: currentGravity,
			lift: currentLift,
			velocity: 0
		};
		
		const topPipeImage = new Image();
		topPipeImage.src = 'pixel art top pipe 4.png';

		const bottomPipeImage = new Image();
		bottomPipeImage.src = 'pixel art bottom pipe 4.png';

		const pipes = [];
        const pipeWidth = 64;
        let pipeGap = 200; 
        let pipeSpeed = 2.25;
        let score = 0;
        let gameRunning = false;
		let pipeCreationInterval;
        let speedUpdateInterval;

        const coins = [];
        const coinWidth = 24;
        const coinHeight = 24;
        let totalCoinsCollected = Number(localStorage.getItem('coins')) || 0;
        let purchasedCharacters = JSON.parse(localStorage.getItem('purchasedCharacters')) || [];

        let backgroundX = 0;
		let moonSurfaceX = 0;

        function resizeCanvas() {
			canvas.width = canvas.clientWidth; // Keep width dynamic
			canvas.height = canvas.clientHeight; // Update height dynamically
			pipeGap = 200;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

    let lastRotationAngle = 0; // Add a variable to store the last rotation angle

	function drawTurtle() {
    // Calculate the rotation angle based on velocity
    let targetRotationAngle = Math.min(Math.max(turtle.velocity / 5, -2), 2) * 45;

    // Smooth the rotation by interpolating between the last angle and the target angle
    let dampingFactor = 0.2; // Increase the damping factor for more pronounced rotations
    lastRotationAngle += (targetRotationAngle - lastRotationAngle) * dampingFactor;

    ctx.save();
    ctx.translate(turtle.x + turtle.width / 2, turtle.y + turtle.height / 2); // Move to the turtle's center
    ctx.rotate((Math.PI / 180) * lastRotationAngle); // Rotate based on the smoothed angle
    ctx.drawImage(characterImages[selectedCharacter], -turtle.width / 2, -turtle.height / 2, turtle.width, turtle.height);
    ctx.restore();
}


        function drawCoin(coin) {
            ctx.drawImage(coinImage, coin.x, coin.y, coin.width, coin.height);
        }
        const coinSound = new Audio(); // Replace with the correct path to your MP3 file
		coinSound.src = 'coin.mp3';
		const jumpSound = new Audio(); // Replace with the correct path to your MP3 file
		jumpSound.src = 'flap01.mp3';
        const backgroundMusic = new Audio(''); // Replace with the correct path to your MP3 file
		backgroundMusic.loop = true; // Loop s://flapthe background music
		const collisionSound = new Audio();
		collisionSound.src = 'collision.mp3';
		const gameOverSound = new Audio();
		gameOverSound.src = 'die.mp3';
		const scoreSound = new Audio(); // Replace with the correct path to your MP3 file
		scoreSound.src = 'point.mp3';


		function clearCanvas() {
			ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear entire canvas

			// Redraw the background
			backgroundX -= pipeSpeed * 0.25;
			if (backgroundX <= -canvas.width) {
				backgroundX = 0;
			}
			ctx.drawImage(backgroundImage, backgroundX, 0, canvas.width, canvas.height);
			ctx.drawImage(backgroundImage, backgroundX + canvas.width, 0, canvas.width, canvas.height);

			// Add scrolling effect for the moon surface
			moonSurfaceX -= pipeSpeed * 0.5; // Move the moon surface to the left
			if (moonSurfaceX <= -canvas.width) {
				moonSurfaceX = 0; // Reset position to create a seamless loop
			}
			ctx.drawImage(moonSurfaceImage, moonSurfaceX, canvas.height - moonSurfaceImage.height, canvas.width, moonSurfaceImage.height);
			ctx.drawImage(moonSurfaceImage, moonSurfaceX + canvas.width, canvas.height - moonSurfaceImage.height, canvas.width, moonSurfaceImage.height);
		}


function createTopPipes() {
    const topPipeHeight = topPipeImage.height; // Height of the top pipe image
    const topPipeWidth = topPipeImage.width; // Width of the top pipe image
	const bottomPipeHeight = bottomPipeImage.height; // Height of the bottom pipe image
    const bottomPipeWidth = bottomPipeImage.width; // Width of the bottom pipe image
    const moonSurfaceHeight = moonSurfaceImage.height; // Height of the moon surface image
    const initialGap = 200; // The initial gap size between pipes

    // Calculate the range for the bottom of the top pipe
    const minTopPipeHeight = 50; // Minimum Y position from the top of the canvas
    const maxTopPipeHeight = canvas.height - (initialGap + 1.5 * moonSurfaceHeight); // Maximum Y position

    // Generate a random Y position for the bottom of the top pipe within the range
    const topPipeY = Math.random() * (maxTopPipeHeight - minTopPipeHeight) + minTopPipeHeight - topPipeHeight;
    const topPipeX = canvas.width; // Start at the right edge of the screen
	const bottomPipeX = canvas.width; // Start at the right edge of the screen
	const bottomPipeY = topPipeY + topPipeHeight + initialGap;

    // Create the top pipe
    pipes.push({
        x: topPipeX,
        y: topPipeY,
        width: topPipeWidth,
        height: topPipeHeight,
		type: 'top'
    });

    // Create the bottom pipe	
	    pipes.push({
        x: bottomPipeX,
        y: bottomPipeY,
        width: bottomPipeWidth,
        height: bottomPipeHeight,
		type: 'bottom',
        scored: false
    });
	
	// Add a coin between the pipes with a 100% chance
			if (Math.random() < 1/3) {
				const coinY = topPipeY + topPipeHeight + (initialGap - coinHeight) / 2; // Center the coin in the gap
				const coinX = canvas.width + (topPipeWidth / 2) - (coinWidth / 2); // Center the coin horizontally
				coins.push({
					x: coinX,
					y: coinY,
					width: coinWidth,
					height: coinHeight,
					collected: false
				});
			}
}



// Function to draw the top pipes
function drawTopPipes() {
    pipes.forEach(pipe => {
        if (pipe.type === 'top') {
            // Draw the top pipe
            ctx.drawImage(topPipeImage,pipe.x,pipe.y,pipe.width,pipe.height);
        } else if (pipe.type === 'bottom') {
            // Draw the bottom pipe
            ctx.drawImage(bottomPipeImage,pipe.x,pipe.y,pipe.width,pipe.height);
        }
		// Draw the red collision box
        //ctx.strokeStyle = 'red'; // Set stroke color
        //ctx.lineWidth = 2; // Line thickness for visibility
        //ctx.strokeRect(pipe.x, pipe.y, pipe.width, pipe.height); // Draw rectangle
    });
}       
        





		document.getElementById('clearCacheButton').addEventListener('click', function() {
			// Display confirmation dialog
			if (confirm("Are you sure you want to clear the cache?")) {
				// Clear the cache if user confirms
				localStorage.clear();
				alert('All progress has been reset!');
				// Optionally, refresh the page to apply changes
				location.reload();
			}
		});


        function drawCoins() {
            coins.forEach(coin => {
                if (!coin.collected) {
                    drawCoin(coin);
                }
            });
        }

        function updateSpeed() {
            pipeSpeed += 0.075;
        }

        const characterImages = {};
        function preloadCharacterImages() {
            for (const key in characters) {
                const img = new Image();
                img.src = characters[key];
                characterImages[key] = img;
            }
        }

        preloadCharacterImages();


function updateTopPipes() {
    pipes.forEach((pipe, index) => {
        pipe.x -= pipeSpeed; // Move the pipe to the left

        // Check if the pipe is completely offscreen
        if (pipe.x + pipe.width < 0) {
            pipes.splice(index, 1); // Remove the pipe from the array
        }
    });
}



		function updateCoins() {
			coins.forEach(coin => {
				coin.x -= pipeSpeed; // This also scales with pipeSpeed
			});

			// Remove coins that move off-screen
			if (coins.length && coins[0].x + coinWidth < 0) {
				coins.shift();
			}
		}

        document.addEventListener('keydown', function(event) {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(event.key)) {
        event.preventDefault();
    }
});





function detectCollision() {
    const turtleLeft = turtle.x + turtle.width * 0.2; // Left side of the turtle (20% inward)
    const turtleRight = turtle.x + turtle.width * 0.8; // Right side of the turtle (80% inward)
    const turtleTop = turtle.y + turtle.height * 0.25; // Top side of the turtle (25% inward)
    const turtleBottom = turtle.y + turtle.height * 0.75; // Bottom side of the turtle (75% inward)

    // Draw turtle collision box for debugging
    //ctx.strokeStyle = 'red';
    //ctx.lineWidth = 2;
    //ctx.strokeRect(turtleLeft, turtleTop, turtleRight - turtleLeft, turtleBottom - turtleTop);

    // Check for canvas top or bottom collision
    if (turtleTop <= 0 || turtleBottom >= canvas.height - moonSurfaceImage.height) {
        collisionSound.play();
		return true; // Collision detected
    }

    // Check for pipe collision
    for (let i = 0; i < pipes.length; i++) {
        const pipe = pipes[i];
        const pipeLeft = pipe.x;
        const pipeRight = pipe.x + pipe.width;
        const pipeTop = pipe.y;
        const pipeBottom = pipe.y + pipe.height;

        // Check if turtle collides with the pipe
        if (
            turtleRight > pipeLeft &&
            turtleLeft < pipeRight &&
            turtleBottom > pipeTop &&
            turtleTop < pipeBottom
        ) {
            collisionSound.play();
			return true; // Collision detected
        }
    }

    return false; // No collision detected
}


        function detectCoinCollection() {
    for (let i = 0; i < coins.length; i++) {
        if (!coins[i].collected &&
            turtle.x < coins[i].x + coinWidth &&
            turtle.x + turtle.width > coins[i].x &&
            turtle.y < coins[i].y + coinHeight &&
            turtle.y + turtle.height > coins[i].y) {
            coins[i].collected = true;
            //totalCoinsCollected=totalCoinsCollected+500;
			totalCoinsCollected++;
            playCoinSound(); // Play sound effect
            updateCoinCount();
            coins.splice(i, 1);
            i--;
        }
    }
}

// Function to update gravity and lift dynamically
function updateGravityAndLift() {
    if (!gravityIncreaseStartTime) {
        gravityIncreaseStartTime = performance.now();
    }
    const elapsedTime = performance.now() - gravityIncreaseStartTime;

    if (elapsedTime <= gravityIncreaseDuration) {
        const progress = elapsedTime / gravityIncreaseDuration;
        currentGravity = initialGravity + progress * (maxGravity - initialGravity);
        currentLift = initialLift + progress * (maxLift - initialLift);
    } else {
        currentGravity = maxGravity;
        currentLift = maxLift;
    }

    turtle.gravity = currentGravity;
    turtle.lift = currentLift;
}


// Update function modified to include gravity updates
function update() {
    if (!gameRunning) return;
    // Update gravity and lift
    updateGravityAndLift();

    clearCanvas();
    drawTurtle();
    // Draw and move top pipes
    drawTopPipes();
	
    drawCoins();
    turtle.velocity += turtle.gravity; // Apply the updated gravity
    turtle.y += turtle.velocity;
	updateTopPipes();
    updateCoins();

    if (detectCollision()) {
        gameOver();
        return; // Exit the update loop if a collision is detected
    }

    detectCoinCollection();

	for (let i = 1; i < pipes.length; i += 2) {
        if (turtle.x > (pipes[i].x*2/3) && !pipes[i].scored) {
            score++;
            //console.log(`Scoring pipe ${i}, X: ${pipes[i].x}, Scored: ${pipes[i].scored}, Turtle position ${turtle.x},pipeWidth ${pipeWidth}`);
			pipes[i].scored = true;
            updateScore();
        }
    }

    requestAnimationFrame(update);
}

let previousScore = 0;
       // Function to update the score and play the sound effect
function updateScore() {
    if (score > previousScore) {
        scoreSound.play(); // Play score sound effect
    }
    previousScore = score;
    document.getElementById('scoreText').textContent = 'Score: ' + score;
}
    function updateCoinCount() {
		document.getElementById('coinText').textContent = 'Coins: ' + totalCoinsCollected;
		localStorage.setItem('coins', totalCoinsCollected); // Save to localStorage
}


function updatePurchasedCharacters() {
    const purchasedContainer = document.getElementById('purchasedCharacters');
    purchasedContainer.innerHTML = '';

    purchasedCharacters.forEach(character => {
        const characterItem = document.createElement('div');
        characterItem.className = 'character-item';
        characterItem.setAttribute('data-character', character);

        const characterImg = new Image();
        characterImg.src = characters[character];
        characterImg.alt = character;

        characterItem.appendChild(characterImg);
        purchasedContainer.appendChild(characterItem);
    });

    localStorage.setItem('purchasedCharacters', JSON.stringify(purchasedCharacters));
}


        function jump() {
            turtle.velocity = turtle.lift;
        }
		
		function playJumpSound() {
			jumpSound.pause();  // Stop the current playback
			jumpSound.currentTime = 0;  // Reset to the beginning
			jumpSound.play();  // Play the sound
		}
		
		function playCoinSound() {
			coinSound.pause();  // Stop the current playback
			coinSound.currentTime = 0;  // Reset to the beginning
			coinSound.play();  // Play the sound
		}

        function keyDown(e) {
			if (e.key === ' ' || e.code === 'Space' || e.code === 'ArrowUp' ) {
				jump();
				playJumpSound(); // Play jump sound effect
			}
			
		}
		
		// Handle mouse click for jump
		function mouseDown(event) {
			const rect = canvas.getBoundingClientRect();
			const clickX = event.clientX - rect.left;
			const clickY = event.clientY - rect.top;

			// Check if the click is within the canvas bounds
			if (clickX >= 0 && clickX <= canvas.width && clickY >= 0 && clickY <= canvas.height) {
				jump();
				playJumpSound(); // Play jump sound effect
			}
		}

		function touchStart(event) {
			const rect = canvas.getBoundingClientRect();
			const touchX = event.touches[0].clientX - rect.left;
			const touchY = event.touches[0].clientY - rect.top;

			if (touchX >= 0 && touchX <= canvas.width && touchY >= 0 && touchY <= canvas.height) {
				jump();
				playJumpSound(); // Play jump sound effect
			}
		}
document.addEventListener('keydown', keyDown);
canvas.addEventListener('touchstart', touchStart);

let pipeSpeedIncreaseInterval;

function startGame() {
    const username = localStorage.getItem('username');
    if (!username) {
        document.getElementById('usernameModal').style.display = 'block';
        return; // Prevent starting the game if username is not set
    }
	
    // Login to PlayFab with the username
    loginToPlayFab(username, function () {
        console.log("Player successfully logged into PlayFab");


    // Stop any running intervals or timers
	clearInterval(pipeCreationInterval);
    clearInterval(pipeSpeedIncreaseInterval);
    clearInterval(speedUpdateInterval);

    // Reset game parameters
    gameRunning = true;
    isPaused = false;
    score = 0;
    previousScore = 0; // Reset previousScore when the game starts
    turtle.x = canvas.width / 20;
    turtle.y = canvas.height / 2 - 25;
    turtle.velocity = 0;
	pipes.length = 0;
    coins.length = 0;
	pipeSpeed = 2.25;

    // Reset gravity-related parameters
    currentGravity = initialGravity; // Reset to initial gravity
    currentLift = initialLift;       // Reset to initial lift
    gravityIncreaseStartTime = null; // Reset the gravity transition timer
    turtle.gravity = currentGravity; // Apply initial gravity
    turtle.lift = currentLift;       // Apply initial lift

    // Update UI
    document.getElementById('clearCacheButton').style.display = 'none';
    document.getElementById('startButton').style.display = 'none';
    document.getElementById('tweetScoreButton').style.display = 'none';
    document.getElementById('muteButton').style.display = 'none';
    document.getElementById('shopButton').style.display = 'none';
    document.getElementById('selectCharacterButton').style.display = 'none';
    document.getElementById('highscoreButton').style.display = 'none'; // Hide highscore button
    document.getElementById('scoreText').style.display = 'block';
    document.getElementById('coinText').style.display = 'block';
    document.getElementById('pauseButton').style.display = 'block'; // Show the pause button

    // Reset music
    backgroundMusic.currentTime = 0;
    backgroundMusic.play();

    // Update score and start the game loop
    updateScore();
    update();
	pipeCreationInterval = setInterval(createTopPipes, 1750);
	pipeSpeedIncreaseInterval = setInterval(increasePipeSpeed, 2500);
    speedUpdateInterval = setInterval(updateSpeed, 2500);
	});
	
	
}


// Function to handle PlayFab login
function loginToPlayFab(username, callback) {
    PlayFabClientSDK.LoginWithCustomID({
        TitleId: PlayFab.settings.titleId, // Your PlayFab Title ID
        CustomId: username,
        CreateAccount: true // Create an account if it doesn't exist
    }, function (result) {
        console.log("Logged into PlayFab:", result);
        if (callback) callback(); // Proceed to start the game
    }, function (error) {
        console.error("Error logging into PlayFab:", error);
        alert("Could not log in to PlayFab. Check your internet connection.");
    });
}





function increasePipeSpeed() {
    pipeSpeed += 0.075; // Pas de snelheidstoename aan zoals gewenst
}

document.querySelectorAll('button').forEach(button => {
    button.addEventListener('click', (event) => {
        event.stopPropagation(); // Prevent the canvas click event when clicking on buttons
    });
});

// Add the event listener for the tweet score button
document.getElementById('tweetScoreButton').addEventListener('click', tweetScore);

// Function to tweet the score
function tweetScore() {
    const tweetText = `I reached a score of ${score} in Bonkey Bird! Can you beat my score? `;
    const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(tweetText)}`;
    window.open(tweetUrl, '_blank');
}

// Show the tweet score button when game over
function gameOver() {
    gameRunning = false;
	clearInterval(pipeCreationInterval);
    clearInterval(speedUpdateInterval);
	clearInterval(pipeSpeedIncreaseInterval);
    backgroundMusic.pause();
    backgroundMusic.currentTime = 0;
    gameOverSound.play();
    updateHighscore();
    document.getElementById('startButton').style.display = 'block';
    document.getElementById('tweetScoreButton').style.display = 'block';
    document.getElementById('clearCacheButton').style.display = 'block';
	document.getElementById('shopButton').style.display = 'block';
    document.getElementById('muteButton').style.display = 'block';
    document.getElementById('selectCharacterButton').style.display = 'block';
    document.getElementById('highscoreButton').style.display = 'block';
    document.getElementById('pauseButton').style.display = 'none'; // Hide the pause button on game over
    document.getElementById('tweetScoreButton').style.display = 'block'; // Show tweet score button
    document.getElementById('startButton').textContent = 'Restart Game';
    localStorage.setItem('score', score);
	
    // No coin counter reset here!
    const username = localStorage.getItem('username');
    submitHighscore(username, score); // Submit the highscore
}




function submitHighscore(username, score) {
    // Set the display name (username) for the player
    PlayFabClientSDK.UpdateUserTitleDisplayName({
        DisplayName: username // Set the player's username
    }, function (result) {
        console.log("Username submitted successfully:", result);

        // Then update the player's statistics
        PlayFabClientSDK.UpdatePlayerStatistics({
            Statistics: [{
                StatisticName: "Highscore_mobile",
                Value: score
            }]
        }, function (result) {
            console.log("Highscore submitted successfully:", result);
        }, function (error) {
            console.error("Error submitting highscore:", error);
        });

    }, function (error) {
        console.error("Error submitting username:", error);
    });
}



function fetchHighscores() {
    PlayFabClientSDK.GetLeaderboard({
        StartPosition: 0,
        MaxResultsCount: 10,
        StatisticName: "Highscore_mobile"
    }, function (result) {
        console.log("Leaderboard data:", result.data.Leaderboard);
        const leaderboardData = result.data.Leaderboard;

        const highscoreModal = document.getElementById('highscoreModal');
        const highscoreList = document.getElementById('highscoreList');
        highscoreList.innerHTML = '';

        leaderboardData.forEach(entry => {
            const listItem = document.createElement('p');
            listItem.innerText = `Rank ${entry.Position + 1}: ${entry.DisplayName || "Anonymous"} - ${entry.StatValue}`;
            highscoreList.appendChild(listItem);
        });

        highscoreModal.style.display = 'block';
    }, function (error) {
        console.error("Error fetching leaderboard:", error);
    });
}


document.getElementById('highscoreButton').addEventListener('click', () => {
    fetchHighscores();
    document.getElementById('highscoreModal').style.display = 'block';
});



function openShop() {
    const shopModal = document.getElementById('shopModal');
    const characterContainer = document.getElementById('characters');
    const coinCountDisplay = document.getElementById('coinCountDisplay');

    // Update the coin count display with the current number of coins
    coinCountDisplay.textContent = 'Coins: ' + totalCoinsCollected;

    characterContainer.querySelectorAll('.character-item').forEach(item => {
        const character = item.getAttribute('data-character');
        const priceElement = item.querySelector('p');
        const price = parseInt(priceElement.textContent.split(' ')[0]); // Extract the price

        if (purchasedCharacters.includes(character)) {
            priceElement.textContent = 'Purchased'; // Mark as purchased
            priceElement.style.color = 'green';
            item.style.pointerEvents = 'none'; // Disable interaction
        } else if (totalCoinsCollected < price) {
            priceElement.style.color = 'red'; // Show insufficient coins in red
        } else {
            priceElement.style.color = 'black'; // Reset color for affordable characters
            item.style.pointerEvents = 'auto'; // Enable interaction
        }
    });

    shopModal.style.display = 'block';
}


        function closeShop() {
            document.getElementById('shopModal').style.display = 'none';
        }

        function openSelectCharacter() {
            document.getElementById('selectCharacterModal').style.display = 'block';
        }

        function closeSelectCharacter() {
            document.getElementById('selectCharacterModal').style.display = 'none';
        }

function buyCharacter(event) {
    // Ensure we always get the closest parent `.character-item`
    const characterItem = event.target.closest('.character-item');
    if (!characterItem) {
        alert('Error: Unable to identify character.');
        return;
    }

    const selected = characterItem.getAttribute('data-character');
    const prices = {
        character2: 25,
        character3: 50,
        character4: 75,
        character5: 100,
        character6: 150,
		character7: 200,
    };

    const selectedPrice = prices[selected];

    if (totalCoinsCollected >= selectedPrice && !purchasedCharacters.includes(selected)) {
        purchasedCharacters.push(selected);
        totalCoinsCollected -= selectedPrice;
        selectedCharacter = selected; // Set the selected character to the purchased one
        updateCoinCount();
        updatePurchasedCharacters();
        localStorage.setItem('selectedCharacter', selectedCharacter); // Save the selected character
        alert(`Character ${selected} purchased and selected!`);
        openSelectCharacter(); // Update the inventory UI
        closeShop();
    } else if (purchasedCharacters.includes(selected)) {
        alert('Character already purchased!');
    } else {
        alert('Not enough coins!');
    }
}





function selectCharacter(event) {
    const characterItem = event.target.closest('.character-item');
    if (!characterItem) {
        alert('Error: Unable to identify character.');
        return;
    }

    const selected = characterItem.getAttribute('data-character');
    if (purchasedCharacters.includes(selected)) {
        selectedCharacter = selected;
        localStorage.setItem('selectedCharacter', selectedCharacter);
        alert(`Character ${selected} selected!`);
        closeSelectCharacter();
    }
}


        document.getElementById('startButton').addEventListener('click', startGame);
        document.getElementById('shopButton').addEventListener('click', openShop);
        document.getElementById('shopModalClose').addEventListener('click', closeShop);
        document.getElementById('selectCharacterButton').addEventListener('click', openSelectCharacter);
        document.getElementById('selectCharacterModalClose').addEventListener('click', closeSelectCharacter);
        document.getElementById('characters').addEventListener('click', buyCharacter);
        document.getElementById('purchasedCharacters').addEventListener('click', selectCharacter);
        document.addEventListener('keydown', keyDown);
        canvas.addEventListener('touchstart', touchStart);
		canvas.addEventListener('mousedown', mouseDown);

document.addEventListener('DOMContentLoaded', () => {
    totalCoinsCollected = Number(localStorage.getItem('coins')) || 0;
    purchasedCharacters = JSON.parse(localStorage.getItem('purchasedCharacters')) || [];
    selectedCharacter = localStorage.getItem('selectedCharacter') || 'character1';

 const muteButton = document.getElementById('muteButton');
    if (muteButton) {
        muteButton.addEventListener('click', toggleMute);
    } else {
        console.error('Mute button element not found');
    }

    // Add default character to purchased characters if not already present
    if (!purchasedCharacters.includes('character1')) {
        purchasedCharacters.push('character1');
    }
fetchHighscores();
    updateCoinCount();
    updatePurchasedCharacters();
});

canvas.addEventListener('click', (event) => {
    const username = localStorage.getItem('username');
    if (!username) {
        event.stopPropagation(); // Stop event propagation
        document.getElementById('usernameModal').style.display = 'block';
    }
});

document.getElementById('saveUsernameButton').addEventListener('click', () => {
    const username = document.getElementById('usernameInput').value.trim();
    const validUsernameRegex = /^[a-zA-Z0-9\s_]+$/; // Allows letters, numbers, spaces, and underscores

    if (username.length < 3) {
        document.getElementById('usernameValidationMessage').textContent = 'Username must be at least 3 characters long.';
    } else if (username.length > 20) {
        document.getElementById('usernameValidationMessage').textContent = 'Username must be 20 characters or less.';
    } else if (!username) {
        document.getElementById('usernameValidationMessage').textContent = 'Please enter a valid username.';
    } else if (!validUsernameRegex.test(username)) {
        document.getElementById('usernameValidationMessage').textContent = 'Usernames can only contain letters, numbers, spaces, and underscores.';
    } else {
        // Sanitize the username for further use
        const sanitizedUsername = username.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        localStorage.setItem('username', sanitizedUsername);
        document.getElementById('usernameModal').style.display = 'none';
    }
});



function updateHighscore() {
    const username = localStorage.getItem('username');
    const highscore = Number(localStorage.getItem('highscore')) || 0;

    if (score > highscore) {
        localStorage.setItem('highscore', score);
        localStorage.setItem('highscoreUsername', username);
    }
}

document.getElementById('highscoreButton').addEventListener('click', () => {
    populateHighscoreList();
    document.getElementById('highscoreModal').style.display = 'block';
});




function populateHighscoreList() {
    const highscore = localStorage.getItem('highscore') || 0;
    const highscoreUsername = localStorage.getItem('highscoreUsername') || 'No one';
    const highscoreList = document.getElementById('highscoreList');
    highscoreList.innerHTML = `<p>Highscore: ${highscore} by ${highscoreUsername}</p>`;
}




function closeHighscoreModal() {
    document.getElementById('highscoreModal').style.display = 'none';
}

document.getElementById('highscoreModalClose').addEventListener('click', closeHighscoreModal);


        turtleImage.onload = function() {
            document.getElementById('startButton').style.display = 'block';
            document.getElementById('shopButton').style.display = 'block';
            document.getElementById('selectCharacterButton').style.display = 'block';
        };
        
        
let isPaused = false;

// Function to toggle pause
function togglePause() {
    if (isPaused) {
        // Resume the game
        isPaused = false;
        gameRunning = true;
        backgroundMusic.play();
        update();
		pipeCreationInterval = setInterval(createTopPipes, 1750);
		pipeSpeedIncreaseInterval = setInterval(increasePipeSpeed, 2500);
        speedUpdateInterval = setInterval(updateSpeed, 2500);
        document.getElementById('pauseButton').textContent = 'Pause';
    } else {
        // Pause the game
        isPaused = true;
        gameRunning = false;
        backgroundMusic.pause();
		clearInterval(pipeCreationInterval);
		clearInterval(pipeSpeedIncreaseInterval);
        clearInterval(speedUpdateInterval);
        document.getElementById('pauseButton').textContent = 'Resume';
    }
}


// Add event listener for the "P" key to toggle pause
document.addEventListener('keydown', function(event) {
    if (event.key === 'p' || event.key === 'P') {
        togglePause();
    }
});

// Add event listener for the pause button to toggle pause
document.getElementById('pauseButton').addEventListener('click', togglePause);
        
let isMuted = false;

function toggleMute() {
    isMuted = !isMuted;
    
    const audioElements = [coinSound, backgroundMusic, gameOverSound, scoreSound];
    
    audioElements.forEach(audio => {
        audio.muted = isMuted;
    });

    const muteButton = document.getElementById('muteButton');
    muteButton.textContent = isMuted ? 'Unmute' : 'Mute';
}


    </script>
</body>
</html>